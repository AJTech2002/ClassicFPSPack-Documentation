using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using System.IO;
using ClassicFPS.Saving_and_Loading;
using UnityEngine.SceneManagement;

namespace ClassicFPS.Managers
{
    //Very simple list of functions to be called to save/load states
    public class SaveManager : MonoBehaviour
    {
        [Header("Save Format")]
        [SerializeField] bool binary; //Binary save type (includes basic encryption)

        [Header("Save Options")]
        [SerializeField] string overrideSavePath = "";
        [SerializeField] bool usePersistentDataPath = true;
        [SerializeField] bool testing;

        public static bool currentlySaving = false;

        [HideInInspector]
        private static SaveManager _instance;

        //Make sure there is always an instance even when moving between scenes
        public static SaveManager instance
        {
            get {
                if (_instance == null) _instance = GameObject.FindObjectOfType<SaveManager>();
                return _instance;
            }
            set {
                _instance = value;
            }
        }
        
        [Header("Testing Save Inputs")]
        [SerializeField] InputAction saveInputAction; //Testing Save Action
        [SerializeField] InputAction loadAction; //Testing Load Action

        [Header("DEBUG [ READONLY ]")]
        [SerializeField] private string selectedSavePath = "";

        //Current Saver (Can be binary or text look at SaveTypes.cs)
        private ISaver _saveHelper;
        public ISaver saveHelper
        {
            get
            {
                if (_saveHelper == null)
                {
                    if (binary) _saveHelper = new BinaryEncryptedSaver();
                    else _saveHelper = new SimpleTextSaver();
                }

                return _saveHelper;
            }
            set
            {
                _saveHelper = value;
            }
        }

        private void Awake()
        {
            instance = this;

            if (usePersistentDataPath) selectedSavePath = Application.persistentDataPath;
            else selectedSavePath = overrideSavePath;

            saveInputAction.Enable();
            saveInputAction.performed += SaveInputAction_performed;

            //TODO: Remove this, this is for testing only
            loadAction.Enable();
            loadAction.performed += LoadAction_performed;
            
            //Determine which saver to use
            if (binary) saveHelper = new BinaryEncryptedSaver();
            else saveHelper = new SimpleTextSaver();

        }

        private static string GetSavingDataPath ()
        {
            if (instance.usePersistentDataPath) return Application.persistentDataPath;
            else return instance.overrideSavePath;
        }

        public static void LoadLevelContents()
        {
            instance.StartCoroutine("Delayed_Load");
        }

        public IEnumerator Delayed_Load()
        {
            //Small delay to let all the items in the scene to begin 
            yield return new WaitForEndOfFrame();
            yield return new WaitForEndOfFrame();

            LoadAllStates();
        }

        private void LoadAction_performed(InputAction.CallbackContext obj)
        {
            if (instance.testing)
            {
                print("Has Loaded!");
                LoadAllStates();
            }
        }

        private void SaveInputAction_performed(InputAction.CallbackContext obj)
        {
            //Only allow for a save if the Player is at the Save point
            if (instance.testing)
            {
                print("Has Saved!");
                instance.StartCoroutine("SaveAllStates");
            }
        }

        //Saves all states
        public static void SaveAllAsync()
        {
            instance.StartCoroutine("SaveAllStates");
        }
        
        //Write a file seperately (if its part of a group then you'll have to save with all)
        public static void SaveStateToFile(State state)
        {
            if (state == null) return;
            if (state.ShouldSave())
            {
                string json = state.SaveState();
                instance.WriteFile(SaveManager.GetSavingDataPath() + "/" + ProcessedUID(state) + ".save", json);
            }
        }
        
        //Get the Processed UID from the current Saver
        public static string ProcessedUID (State state)
        {
            if (state == null) return "";
            return instance.saveHelper.ProcessUID(state.GetUID());
        }

        public static void LoadAll()
        {
            instance.LoadAllStates();
        }
        
        //Check if there are any save files
        public static bool HasSaveFiles()
        {
            if (GameObject.FindObjectOfType<GameState>() == null)
            {
                Debug.LogError("A GameState Component is required in the scene");
                return false;
            }

            //Check if a GameState save file exists (which is the global save file)
            string fileLocation = SaveManager.GetSavingDataPath() + "/" + ProcessedUID(GameObject.FindObjectOfType<GameState>()) + ".save";

            //If it exists then there is saved progress
            if (File.Exists(fileLocation))
            {
                return true;
            }

            return false;
        }

        //Check if there are any save files for the current scene [Only works for Text Saver]    
        public static bool HasSaveFilesForScene(string sceneName)
        {
            //Find all files with extension .save in the SaveManager.GetSavingDataPath() path
            DirectoryInfo d = new DirectoryInfo(SaveManager.GetSavingDataPath());
            FileInfo[] Files = d.GetFiles("*.save");

            if (Files != null && Files.Length >= 1) 
            {
                for (int i = 0; i < Files.Length; i++)
                {
                    string nameCheck = Files[i].Name.Replace(".save", "");
                    if (instance.saveHelper.UnprocessedUID(nameCheck).Contains(sceneName))
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        
        //Delete all saves
        public static void ClearAllSaves()
        {
            //Find all files with extension .save in the SaveManager.GetSavingDataPath() path
            DirectoryInfo d = new DirectoryInfo(SaveManager.GetSavingDataPath());
            FileInfo[] Files = d.GetFiles("*.save");

            //For each file, delete it.
            foreach (FileInfo file in Files)
            {

                File.Delete(file.FullName);
            }
        }
        
        //Get the value of a specific state
        public static void LoadStateFromFile(State state)
        {
            if (state == null) return;
            //Find the location of the file (using UID)
            string fileLocation = SaveManager.GetSavingDataPath() + "/" + ProcessedUID(state) + ".save";

            //Make sure the Save file still exists
            if (File.Exists(fileLocation))
            {
                //If it does then read the JSON
                string json = instance.saveHelper.ReadFile(fileLocation);
                state.LoadState(json);
            }
            else {
                state.EmptyLoadState();
            }
        }

        public static bool HasSaveFilesForState(State state)
        {
            string fileLocation = SaveManager.GetSavingDataPath() + "/" + ProcessedUID(state) + ".save";
            if (File.Exists(fileLocation))
                return true;
            else
                return false;
        }

        //Clears all the saves from the current level
        public static void ClearLevelSaves(string sceneName)
        {
            DirectoryInfo d = new DirectoryInfo(SaveManager.GetSavingDataPath());
            FileInfo[] Files = d.GetFiles("*.save");

            if (Files != null && Files.Length >= 1)
            {
                for (int i = 0; i < Files.Length; i++)
                {
                    string nameCheck = Files[i].Name.Replace(".save", "");
                    if (instance.saveHelper.UnprocessedUID(nameCheck).Contains(sceneName))
                    {
                        File.Delete(Files[i].FullName);
                    }
                }
            }
        }

        
        // This method saves all states and ensures it is done before moving on, important if switching scenes
        public static void SaveAllSynchronous ()
        {
            List<State> states = FindAllStates();
            for (int i = 0; i < states.Count; i++)
            {
                State foundState = states[i];
                if (foundState == null) continue;
                if (foundState.ShouldSave())
                {
                    string json = foundState.SaveState();
                    instance.WriteFile(SaveManager.GetSavingDataPath() + "/" + ProcessedUID(foundState) + ".save", json);
                }
            }
        }

        //Method that Saves all the States in the Scene Asynchronously (DONT USE THIS IF SWITCHING SCENES)
        public IEnumerator SaveAllStates()
        {
            currentlySaving = true;
            List<State> states = FindAllStates();
            for (int i = 0; i < states.Count; i++)
            {
                State foundState = states[i];
                if (foundState == null) continue;
                //If the State says it should save (true by default)
                if (foundState.ShouldSave())
                {
                    yield return new WaitForEndOfFrame();
                    //Get the JSON for that Object from the State
                    string json = foundState.SaveState();

                    WriteFile(SaveManager.GetSavingDataPath() + "/" + ProcessedUID(foundState) + ".save", json);

                }
            }
            currentlySaving = false;
        }

        //Ensure the game saves
        public static void EnsureSafeSaving ()
        {
            if (currentlySaving)
            {
                instance.StopAllCoroutines();

                currentlySaving = false;
                SaveAllSynchronous();
            }
        }

        public static List<State> FindAllStates()
        {
            List<State> results = new List<State>();
            List<int> UIDAdded = new List<int>();

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                var s = SceneManager.GetSceneAt(i);
                if (s.isLoaded)
                {
                    var allGameObjects = s.GetRootGameObjects();
                    for (int j = 0; j < allGameObjects.Length; j++)
                    {
                        var go = allGameObjects[j];
                        foreach (State s2 in go.GetComponentsInChildren<State>(true))
                        {
                            results.Add(s2);
                            UIDAdded.Add(s2.GetInstanceID());
                        }
                    }
                }
            }

            foreach (State s in GameObject.FindObjectsOfType<State>())
            {
                if (UIDAdded.Contains(s.GetInstanceID())) continue;
                results.Add(s);
            }

            
            return results;
        }

        public void WriteFile(string path, string json)
        {
            //Write using the current saver
            saveHelper.WriteFile(path, json);
        }

        //Can be called whenever the Game needs to be reloaded
        public void LoadAllStates()
        {
            foreach (State foundState in FindAllStates())
            {
                if (foundState.ShouldLoad())
                {
                    //Find the location of the file (using UID)
                    string fileLocation = SaveManager.GetSavingDataPath() + "/" + ProcessedUID(foundState) + ".save";

                    //Make sure the Save file still exists
                    if (File.Exists(fileLocation))
                    {
                        //If it does then read the JSON
                        string json = instance.saveHelper.ReadFile(fileLocation);
                        foundState.LoadState(json);
                    }
                    else
                        foundState.EmptyLoadState();
                }
            }
        }

        //Function to be called when a checkpoint is reached
        public static void CheckpointReached()
        {
            //Auto start saving states
            print("Checkpoint Reached");
            instance.StartCoroutine("SaveAllStates");
        }

    }

    
}
